# AGENTS – App

Guidance for agents working on `apps/app` (`@hfjp/app`), the TanStack Start SSR app deployed to Cloudflare Workers.

## Scope & Layout
- Entry/runtime glue lives in `src/router.tsx` (router factory) and `src/routes/__root.tsx` (document shell).
- File-based routes: add files under `src/routes/*` using `createFileRoute()` / `createRoute()`. `routeTree.gen.ts` is generated by TanStack – never edit by hand.
- Shared UI in `src/components/*`, shared hooks in `src/hooks/*`, utilities/data in `src/lib` & `src/data`. Global styles: `src/styles.css` (Tailwind v4).
- Assets under `public/`; build artifacts land in `dist/`, `.tanstack/`, `.wrangler/` (gitignored).

## Commands (pnpm only)
- `pnpm -C apps/app dev` – Vite + TanStack Start dev server on `http://localhost:3000` (Workers preview proxied at `8787`).
- `pnpm -C apps/app build` – SSR bundle for Workers (includes client + server output).
- `pnpm -C apps/app preview` (alias `serve`) – Preview last build locally.
- `pnpm -C apps/app test` – Vitest (jsdom) test suite. Use `pnpm -C apps/app test --watch` while iterating.
- `pnpm -C apps/app clean` – Remove build outputs, caches, and local node_modules.
- Type-check via `pnpm check-types --filter @hfjp/app` at repo root when touching TS-heavy code.

## Coding Guidelines
- TypeScript + ESM (`"type": "module"`). `tsconfig` enforces `moduleResolution: "bundler"` and strict mode; imports can use the `@/*` alias → `src/*`.
- React 19 + TanStack Start: prefer `createFileRoute` loaders/actions for data-fetching and mutations. Keep heavy logic in route-level modules, not the router factory.
- Loaders are **isomorphic** in TanStack Start: they run on the server for the initial SSR request and then in the browser on client navigations. Keep them deterministic, side-effect free, and limited to data that can run in both environments.
- When you need privileged logic (secrets, Workers bindings, Node APIs enabled via `nodejs_compat`), move it into server functions (see below) or Worker-bound fetchers, then call those from loaders/actions/components.
- Styling via Tailwind v4 + utility helpers (`clsx`, `tailwind-merge`). Add shared design tokens/components under `src/components/ui`.
- Prefer named exports for components/utilities; default exports only when required by TanStack route definitions.
- Run `pnpm format` at the repo root (Prettier 3) before committing.

## Cloudflare Worker Setup
- Config: `apps/app/wrangler.jsonc` (`main: @tanstack/react-start/server-entry`, `compatibility_flags: ["nodejs_compat"]`). Use Workers bindings for persistence—no filesystem access at runtime.
- Vite config (`vite.config.ts`) already wires `@cloudflare/vite-plugin` with `viteEnvironment: { name: "ssr" }`, `viteTsConfigPaths`, Tailwind, TanStack Start, and React SWC plugin. Keep `server.port = 3000` in sync with docs if you change it.
- Add KV/D1/Queues/etc. in `wrangler.jsonc`, then run `pnpm -C apps/app wrangler types --env-interface CloudflareBindings` (or root `pnpm wrangler types --filter @hfjp/app`) to refresh env typings.

## Routing Workflow
- Create a route file under `src/routes/.../route.tsx` and export `Route = createFileRoute("/path")({ component, loader, action, ... })`.
- Loaders run on the server during SSR and then re-run on the client when navigating; they can return data synchronously or via `defer`. Access the data with `Route.useLoaderData()` and ensure the payload is JSON-serializable for hydration.
- Layouts: `__root.tsx` wraps the entire tree. Nested layouts use `__layout.tsx` conventions inside folders. Never edit `routeTree.gen.ts`; run `pnpm -C apps/app dev` or `pnpm -C apps/app build` to regenerate when adding routes.

## Loaders, Server Functions & SSR
- **Loaders**: Because they are isomorphic, avoid touching Cloudflare bindings or secrets inside the loader body. Instead, call a server function or fetch an API endpoint and return plain data that TanStack Start can serialize into the SSR HTML and hydrate on the client.
- **Server functions**: Use `createServerFn` from `@tanstack/react-start` (see `src/routes/demo/start.server-funcs.tsx`) to declare logic that *only* runs on the server. Server functions can specify HTTP method, middleware, input validators, and access Workers bindings via the handler context (`({ request, env, data }) => { ... }`). Call them with `await myServerFn({ data })` from loaders, actions, or components; TanStack Start transparently invokes them over an internal RPC channel in dev/SSR and bundles them into the Worker for production.
- **SSR flow**: The Worker entry (`@tanstack/react-start/server-entry`) instantiates the router from `getRouter()` and renders the tree on the server, streaming HTML plus loader data to the client. Client hydration reuses the same router config, so keep router options (`scrollRestoration`, preload settings) in `src/router.tsx`. Only return serializable data from loaders/actions, and prefer `router.invalidate()` or `Route.invalidate()` after mutating via a server function so SSR + CSR stay in sync.

## Testing
- Unit/component tests use Vitest + Testing Library (`@testing-library/react`). Place tests next to components with `.test.tsx`.
- For router loaders/actions, prefer testing pure helpers or use `@tanstack/react-router` testing utilities (add as needed).
- No E2E runner yet; document here if you introduce one.

## Deployment & Observability
- Deploy flow: `pnpm -C apps/app build && pnpm -C apps/app wrangler deploy` (or use root `pnpm build` + `pnpm -C apps/app wrangler deploy`).
- Use `pnpm -C apps/app wrangler tail --format pretty` for live logs; observability/traces already on in `wrangler.jsonc`.
- After deploy, smoke-test the Worker URL and any bound routes/APIs.

## Definition of Done (App)
- Routes/components compile, load, and render via Workers preview (no Node-specific APIs).
- Relevant commands (`dev`, `build`, `test`, `preview`) succeed locally.
- Env bindings/types updated when you add/remove bindings.
- Documentation (this file or repo-level `AGENTS.md`) updated if you add scripts, tests, or architectural changes affecting the app team.
